using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Extensions;

using System;
using System.Collections.Generic;
using System.Linq;

using NESEmulatorMacro;

namespace NESEmulator{
	public class CPU {
		mutable A : byte;
		mutable X : byte;
		mutable Y : byte;
		//stack ptr
		mutable S : byte;
		//program counter
		mutable PC : ushort;
		//status register
		mutable SP : byte;

		private P : ProcessorStatus = ProcessorStatus() <- { Reserved = true };
		private Mem : Memory = Memory();

		public Initialize() : void {
			A = 0x0;
			X = 0x0;
			Y = 0x0;
			S = 0x0;
			PC = 0x0;
			SP = 0x0;//TODO:Fix
		}

		public variant Address {
			| None
			| Accumelator
			| Relative
			| Data { addr : ushort }
		};
		public variant Addressing {
			| Accumulator//on Accumulator
			| Immediate//op1 is data
			| Absolute// op1, op2 => {op2, op1} : addr
			| ZeroPage//op1 => { $00, op1} : addr 
			| IndexedZeroPageX//op1 => {$00, op1 + (X | Y)} : addr
			| IndexedZeroPageY//op1 => {$00, op1 + (X | Y)} : addr
			| IndexedAbsoluteX//op1, op2 => { op2, op1 + (X | Y)} : addr
			| IndexedAbsoluteY//op1, op2 => { op2, op1 + (X | Y)} : addr
			| Implied //no address
			| Relative///op1 => {PC + op1} : addr
			| IndexedIndirectX//op1 => {op1 + X + 1, op1 + X} : addr
			| IndexedIndirectY//op1 => {op1 + 1, op1} + Y : addr
			| AbsoluteIndirect//op1, op2 => {{op2, op1} + 1, {op2, op1}} :addr
		};
		public variant OPCode {
			| ADC { addr:Addressing }
			| SBC { addr:Addressing }
			| AND { addr:Addressing }//a
			| ORA { addr:Addressing }//a
			| EOR { addr:Addressing }//a
			| ASL { addr:Addressing }//a <<
			| LSR { addr:Addressing }//a >>
			| ROL { addr:Addressing }// << rotate
			| ROR { addr:Addressing }// >> rotate

			| BCC   //no carry jump
			| BCS   //carry jump
			| BEQ  // == jump
			| BNE   // != jump
			| BVC   //no ovf jump
			| BVS   //ovf jump
			| BPL  //jump if +
			| BMI   //jump if -

			| BIT { addr:Addressing }//and a

			| JMP { addr:Addressing }
			| JSR { addr:Addressing }//call subroutine
			| RTS //return subroutine
			| BRK //software interrupt
			| RTI //return interrupt

			| CMP { addr:Addressing }//a
			| CPX { addr:Addressing }
			| CPY { addr:Addressing }

			| INC { addr:Addressing }//a
			| DEC { addr:Addressing }//a

			| INX
			| DEX
			| INY
			| DEY

			| CLC // clear c
			| SEC // set c
			| CLI // clear i
			| SEI // set i
			| CLD // clear d
			| SED // set d
			| CLV // clear v

			| LDA { addr:Addressing }
			| LDX { addr:Addressing }
			| LDY { addr:Addressing }
			| STA { addr:Addressing }
			| STX { addr:Addressing }
			| STY { addr:Addressing }

			| TAX
			| TXA
			| TAY
			| TYA
			| TXS
			| TSX

			| PHA
			| PLA
			| PHP
			| PLP

			| NOP //none

		};
		public Convert(code : byte) : OPCode {
			| 0x69 => OPCode.ADC(Addressing.Immediate())
			| 0x65 => OPCode.ADC(Addressing.ZeroPage())
			| 0x75 => OPCode.ADC(Addressing.IndexedZeroPageX())
			| 0x6d => OPCode.ADC(Addressing.Absolute())
			| 0x7d => OPCode.ADC(Addressing.IndexedAbsoluteX())
			| 0x79 => OPCode.ADC(Addressing.IndexedAbsoluteY())
			| 0x61 => OPCode.ADC(Addressing.IndexedIndirectX())
			| 0x71 => OPCode.ADC(Addressing.IndexedIndirectY())

			| 0xe9 => OPCode.SBC(Addressing.Immediate())
			| 0xe5 => OPCode.SBC(Addressing.ZeroPage())
			| 0xf5 => OPCode.SBC(Addressing.IndexedZeroPageX())
			| 0xed => OPCode.SBC(Addressing.Absolute())
			| 0xfd => OPCode.SBC(Addressing.IndexedAbsoluteX())
			| 0xf9 => OPCode.SBC(Addressing.IndexedAbsoluteY())
			| 0xe1 => OPCode.SBC(Addressing.IndexedIndirectX())
			| 0xf1 => OPCode.SBC(Addressing.IndexedIndirectY())

			| 0x29 => OPCode.AND(Addressing.Immediate())
			| 0x25 => OPCode.AND(Addressing.ZeroPage())
			| 0x35 => OPCode.AND(Addressing.IndexedZeroPageX())
			| 0x2d => OPCode.AND(Addressing.Absolute())
			| 0x3d => OPCode.AND(Addressing.IndexedAbsoluteX())
			| 0x39 => OPCode.AND(Addressing.IndexedAbsoluteY())
			| 0x21 => OPCode.AND(Addressing.IndexedIndirectX())
			| 0x31 => OPCode.AND(Addressing.IndexedIndirectY())

			| 0x09 => OPCode.ORA(Addressing.Immediate())
			| 0x05 => OPCode.ORA(Addressing.ZeroPage())
			| 0x15 => OPCode.ORA(Addressing.IndexedZeroPageX())
			| 0x0d => OPCode.ORA(Addressing.Absolute())
			| 0x1d => OPCode.ORA(Addressing.IndexedAbsoluteX())
			| 0x19 => OPCode.ORA(Addressing.IndexedAbsoluteY())
			| 0x01 => OPCode.ORA(Addressing.IndexedIndirectX())
			| 0x11 => OPCode.ORA(Addressing.IndexedIndirectY())

			| 0x49 => OPCode.EOR(Addressing.Immediate())
			| 0x45 => OPCode.EOR(Addressing.ZeroPage())
			| 0x55 => OPCode.EOR(Addressing.IndexedZeroPageX())
			| 0x4d => OPCode.EOR(Addressing.Absolute())
			| 0x5d => OPCode.EOR(Addressing.IndexedAbsoluteX())
			| 0x59 => OPCode.EOR(Addressing.IndexedAbsoluteY())
			| 0x41 => OPCode.EOR(Addressing.IndexedIndirectX())
			| 0x51 => OPCode.EOR(Addressing.IndexedIndirectY())

			| 0x0a => OPCode.ASL(Addressing.Accumulator())
			| 0x06 => OPCode.ASL(Addressing.ZeroPage())
			| 0x16 => OPCode.ASL(Addressing.IndexedZeroPageX())
			| 0x0e => OPCode.ASL(Addressing.Absolute())
			| 0x1e => OPCode.ASL(Addressing.IndexedAbsoluteX())

			| 0x4a => OPCode.LSR(Addressing.Accumulator())
			| 0x46 => OPCode.LSR(Addressing.ZeroPage())
			| 0x56 => OPCode.LSR(Addressing.IndexedZeroPageX())
			| 0x4e => OPCode.LSR(Addressing.Absolute())
			| 0x5e => OPCode.LSR(Addressing.IndexedAbsoluteX())

			| 0x2a => OPCode.ROL(Addressing.Accumulator())
			| 0x26 => OPCode.ROL(Addressing.ZeroPage())
			| 0x36 => OPCode.ROL(Addressing.IndexedZeroPageX())
			| 0x2e => OPCode.ROL(Addressing.Absolute())
			| 0x3e => OPCode.ROL(Addressing.IndexedAbsoluteX())

			| 0x6a => OPCode.ROR(Addressing.Accumulator())
			| 0x66 => OPCode.ROR(Addressing.ZeroPage())
			| 0x76 => OPCode.ROR(Addressing.IndexedZeroPageX())
			| 0x6e => OPCode.ROR(Addressing.Absolute())
			| 0x7e => OPCode.ROR(Addressing.IndexedAbsoluteX())

			| 0x90 => OPCode.BCC()
			| 0xb0 => OPCode.BCS()
			| 0xf0 => OPCode.BEQ()
			| 0xd0 => OPCode.BNE()
			| 0x50 => OPCode.BVC()
			| 0x70 => OPCode.BVS()
			| 0x10 => OPCode.BPL()
			| 0x30 => OPCode.BMI()

			| 0x24 => OPCode.BIT(Addressing.ZeroPage())
			| 0x2c => OPCode.BIT(Addressing.Absolute())

			| 0x4c => OPCode.JMP(Addressing.Absolute())
			| 0x6c => OPCode.JMP(Addressing.IndexedIndirectX())//TODO?

			| 0x20 => OPCode.JSR(Addressing.Absolute())
			| 0x60 => OPCode.RTS()
			| 0x00 => OPCode.BRK()
			| 0x40 => OPCode.RTI()

			| 0xc9 => OPCode.CMP(Addressing.Immediate())
			| 0xc5 => OPCode.CMP(Addressing.ZeroPage())
			| 0xd5 => OPCode.CMP(Addressing.IndexedZeroPageX())
			| 0xcd => OPCode.CMP(Addressing.Absolute())
			| 0xdd => OPCode.CMP(Addressing.IndexedAbsoluteX())
			| 0xd9 => OPCode.CMP(Addressing.IndexedAbsoluteY())
			| 0xc1 => OPCode.CMP(Addressing.IndexedIndirectX())
			| 0xd1 => OPCode.CMP(Addressing.IndexedIndirectY())

			| 0xe0 => OPCode.CPX(Addressing.Immediate())
			| 0xe4 => OPCode.CPX(Addressing.ZeroPage())
			| 0xec => OPCode.CPX(Addressing.Absolute())

			| 0xC0 => OPCode.CPY(Addressing.Immediate())
			| 0xc4 => OPCode.CPY(Addressing.ZeroPage())
			| 0xcc => OPCode.CPY(Addressing.Absolute())

			| 0xe6 => OPCode.INC(Addressing.ZeroPage())
			| 0xf6 => OPCode.INC(Addressing.IndexedZeroPageX())
			| 0xee => OPCode.INC(Addressing.Absolute())
			| 0xfe => OPCode.INC(Addressing.IndexedAbsoluteX())

			| 0xc6 => OPCode.DEC(Addressing.ZeroPage())
			| 0xd6 => OPCode.DEC(Addressing.IndexedZeroPageX())
			| 0xce => OPCode.DEC(Addressing.Absolute())
			| 0xde => OPCode.DEC(Addressing.IndexedAbsoluteX())

			| 0xe8 => OPCode.INX()
			| 0xca => OPCode.DEX()
			| 0xc8 => OPCode.INY()
			| 0x88 => OPCode.DEY()

			| 0x18 => OPCode.CLC()
			| 0x38 => OPCode.SEC()
			| 0x58 => OPCode.CLI()
			| 0x78 => OPCode.SEI()
			| 0xd8 => OPCode.CLD()
			| 0xf8 => OPCode.SED()
			| 0xb8 => OPCode.CLV()

			| 0xa9 => OPCode.LDA(Addressing.Immediate())
			| 0xa5 => OPCode.LDA(Addressing.ZeroPage())
			| 0xb5 => OPCode.LDA(Addressing.IndexedZeroPageX())
			| 0xad => OPCode.LDA(Addressing.Absolute())
			| 0xbd => OPCode.LDA(Addressing.IndexedAbsoluteX())
			| 0xb9 => OPCode.LDA(Addressing.IndexedAbsoluteY())
			| 0xa1 => OPCode.LDA(Addressing.IndexedIndirectX())
			| 0xb1 => OPCode.LDA(Addressing.IndexedIndirectY())

			| 0xa2 => OPCode.LDX(Addressing.Immediate())
			| 0xa6 => OPCode.LDX(Addressing.ZeroPage())
			| 0xb6 => OPCode.LDX(Addressing.IndexedZeroPageY())
			| 0xae => OPCode.LDX(Addressing.Absolute())
			| 0xbe => OPCode.LDX(Addressing.IndexedAbsoluteY())

			| 0xa0 => OPCode.LDY(Addressing.Immediate())
			| 0xa4 => OPCode.LDY(Addressing.ZeroPage())
			| 0xb4 => OPCode.LDY(Addressing.IndexedZeroPageX())
			| 0xac => OPCode.LDY(Addressing.Absolute())
			| 0xbc => OPCode.LDY(Addressing.IndexedAbsoluteX())

			| 0x85 => OPCode.STA(Addressing.ZeroPage())
			| 0x95 => OPCode.STA(Addressing.IndexedZeroPageX())
			| 0x8d => OPCode.STA(Addressing.Absolute())
			| 0x9d => OPCode.STA(Addressing.IndexedAbsoluteX())
			| 0x99 => OPCode.STA(Addressing.IndexedAbsoluteY())
			| 0x81 => OPCode.STA(Addressing.IndexedIndirectX())
			| 0x91 => OPCode.STA(Addressing.IndexedIndirectY())

			| 0x86 => OPCode.STX(Addressing.ZeroPage())
			| 0x96 => OPCode.STX(Addressing.IndexedZeroPageY())
			| 0x8e => OPCode.STX(Addressing.Absolute())

			| 0x84 => OPCode.STY(Addressing.ZeroPage())
			| 0x94 => OPCode.STY(Addressing.IndexedZeroPageX())
			| 0x8c => OPCode.STY(Addressing.Absolute())

			| 0xaa => OPCode.TAX()
			| 0x8a => OPCode.TXA()
			| 0xa8 => OPCode.TAY()
			| 0x98 => OPCode.TYA()
			| 0x9a => OPCode.TXS()
			| 0xba => OPCode.TSX()

			| 0x48 => OPCode.PHA()
			| 0x68 => OPCode.PLA()
			| 0x08 => OPCode.PHP()
			| 0x28 => OPCode.PLP()

			| 0xea => OPCode.NOP()

			| _ => throw Exception()

		}
		//データアドレッシング
		private dataAddressing(addr:Addressing) : Address {
				//Aレジスタの値をそのまま参照してね
			| Addressing.Accumulator => Address.Accumelator()
				//PCの即値を適用(PCを進めとく)
			| Addressing.Immediate => { def x = PC ; PC++ ; Address.Data(x)}
				//下位アドレス
			| Addressing.ZeroPage => { def x : byte = Mem.Read(PC) ; PC++ ; Address.Data(x) }
			| Addressing.IndexedZeroPageX => { def x : byte = Mem[PC] + X ; PC++ ; Address.Data(x) }
			| Addressing.IndexedZeroPageY => { def x : byte = Mem[PC] + Y ; PC++ ; Address.Data(x) }
				//下位アドレス, 上位アドレス
			| Addressing.Absolute => { def x : ushort = Mem.Read(PC) | (Mem[PC + 1] << 8); PC += 2; Address.Data(x) }
			| Addressing.IndexedAbsoluteX => { def x : ushort = Mem[PC] | (Mem[PC + 1] << 8) + X; PC += 2; Address.Data(x) }
			| Addressing.IndexedAbsoluteY => { def x : ushort = Mem[PC] | (Mem[PC + 1] << 8) + Y; PC += 2; Address.Data(x) }
				//使わない
			| Addressing.Implied => Address.None()
			| Addressing.Relative => Address.Relative()
				//(下位アドレス先 + X)のアドレス先(下位ビット) とその先1byte(上位ビット)
			| Addressing.IndexedIndirectX => { def pt : ushort = Mem[PC] + X; def x  : ushort = Mem[pt] | (Mem[pt + 1] << 8) ; PC++ ;  Address.Data(x) }
				//下位アドレス先のアドレス先(下位ビット) とその先1byte(上位ビット) にYを加算
			| Addressing.IndexedIndirectY => { def pt : ushort = Mem[PC]; def x : ushort= (Mem[pt] | (Mem[pt + 1] << 8)) + Y ; PC++ ;  Address.Data(x) }
				//TODO:Absoluteとどう違うかわからん、というか使われてない
			| Addressing.AbsoluteIndirect => { def x : ushort = Mem[PC] | (Mem[PC + 1] << 8); PC += 2; Address.Data(x) }

			| _ => throw NotImplementedException()

		}
		//アドレッシングした先のMemを読み取る、アドレッシングがNone,Relative,Accumulator等の場合例外
		public readMem(addressing:Addressing) : byte {
			match(dataAddressing(addressing)){
				| Data(_) as d => Mem[d.addr]
				| _ => throw NotImplementedException()
			}
		}
		//アドレッシングした先のMemに書き込む、アドレッシングがNone,Relative,Accumulator等の場合例外
		public writeMem(addressing:Addressing, data:byte) : void {
			match(dataAddressing(addressing)){
				| Data(_) as d => Mem[d.addr] = data
				| _ => throw NotImplementedException()
			}
		}
		//アドレッシングしたアドレスを読み取る。多分Absolute以外使わない。アドレッシングがNone,Relative,Accumulator等の場合例外
		private readAddr(addr:Addressing) : ushort {
			match(dataAddressing(addr)) {
				| Data(_) as d => d.addr
				| _ => throw NotImplementedException()
			}
		}

		public Execute(op : OPCode) : void {
				// Operation
				//NVZC
			| ADC(_) as adc => {
					//A + M + C -> A
					def m = readMem(adc.addr);
					def result = (A + m + conv_i(P.Carry)) :> ushort;

					P.Negative = conv_b(result & 0x80);
					P.Carry = conv_b(result & 0x100);
					P.Overflow = result > 0xff;//TODO:Replace bitop
					P.Zero = result == 0;

					A = result :> byte;
				}
			| SBC(_) as sbc => {
					//A - M - notC -> A
					def m = readMem(sbc.addr);
					def result = (A - m - conv_i(!P.Carry)) :> ushort;

					P.Negative = conv_b(result & 0x80);
					P.Carry = conv_b(result & 0x100);
					P.Overflow = result > 0xff;//TODO:Replace bitop
					P.Zero = result == 0;

					A = result :> byte;
				}
				// Logic Operation
				//NZ
			| AND(_) as an => {
					//A and M -> A
					def m = readMem(an.addr);
					def result = (A & m);

					A = checkFlagNZ(result);
				}
			| ORA(_) as ora => {
					//A or M -> A
					def m = readMem(ora.addr);
					def result = (A | m);

					A = checkFlagNZ(result);
				}
			| EOR(_) as eor => {
					//A xor M -> A
					def m = readMem(eor.addr);
					def result = (A ^ m);

					A = checkFlagNZ(result);
				}
				// Shift, Rotation
			| ASL(addr = Accumulator) => A = implASL(A)
			| ASL(_) as asl => {
					def m = readMem(asl.addr);
					def result = implASL(m);
					writeMem(asl.addr,result);
				}
			| LSR(addr = Accumulator) => A = implLSR(A)
			| LSR(_) as asl => {
					def m = readMem(asl.addr);
					def result = implLSR(m);
					writeMem(asl.addr,result);
				}
			| ROL(addr = Accumulator) => A = implROL(A)
			| ROL(_) as rol => {
					def m = readMem(rol.addr);
					def result = implROL(m);
					writeMem(rol.addr,result);
				}

			| BCC => implBranch(!P.Carry)
			| BCS => implBranch(P.Carry)
			| BEQ => implBranch(P.Zero)
			| BNE => implBranch(!P.Zero)
			| BVC => implBranch(!P.Overflow)
			| BVS => implBranch(P.Overflow)
			| BPL => implBranch(!P.Negative)
			| BMI => implBranch(P.Negative)
				// ZNV
			| BIT(addr = ZeroPage) as bit => {
					def m = readMem(bit.addr);
					def result = A & m;
					P.Zero = result == 0;
					P.Overflow = conv_b(m & 0x40);
					P.Negative = conv_b(m & 0x80);
				}

			| JMP(addr = Absolute) as jmp => {
					//2byteAbsolute読み込み
					PC = readAddr(jmp.addr);
				}
			| JSR(addr = Absolute) as jsr => {
					def addr = readAddr(jsr.addr);
					def pch = (PC >> 8) :> byte;
					def pcl = (PC & 0xff) :> byte;

					implPush(pch);
					implPush(pcl);
					PC = addr;
				}
			| RTS => {
					def pcl = implPop();
					def pch = implPop();
					PC = ((pch << 8) & pcl) + 1;
				}
			| BRK => unless(P.Interrupt) {
						P.Break = true;
						PC++;
						def pch = (PC >> 8) :> byte;
						def pcl = (PC & 0xff) :> byte;

						implPush(pch);
						implPush(pcl);
						implPush(P.GetValue());

						P.Interrupt = true;
						//0xfffe~0xffff IRQ
						PC = (Mem[Memory.BRK_VECT_H] << 8) | Mem[Memory.BRK_VECT_L];
					}
			| RTI => {
					P.SetValue(implPop());
					def pcl = implPop();
					def pch = implPop();
					PC = ((pch << 8) & pcl) + 1;
				}

			| CMP(_) as cmp => implCMP(A,readMem(cmp.addr))
			| CPX(_) as cpx => implCMP(X,readMem(cpx.addr))
			| CPY(_) as cpy => implCMP(Y,readMem(cpy.addr))

			| INC(_) as inc => {
					def addr = readAddr(inc.addr);
					Mem[addr] = implINC(Mem[addr]);
				}
			| DEC(_) as dec => {
					def addr = readAddr(dec.addr);
					Mem[addr] = implDEC(Mem[addr]);
				}
			| INX => X = implINC(X)
			| DEX => X = implDEC(X)
			| INY => Y = implINC(Y)
			| DEY => Y = implDEC(Y)

			| CLC => P.Carry = false
			| SEC => P.Carry = true
			| CLI => P.Interrupt = false
			| SEI => P.Interrupt = true
			| CLD => P.Decimal = false
			| SED => P.Decimal = true
			| CLV => P.Overflow = false

			| LDA(_) as lda => A = checkFlagNZ(readMem(lda.addr))
			| LDX(_) as ldx => X = checkFlagNZ(readMem(ldx.addr))
			| LDY(_) as ldy => Y = checkFlagNZ(readMem(ldy.addr))

			| STA(_) as sta => writeMem(sta.addr,A)
			| STX(_) as stx => writeMem(stx.addr,X)
			| STY(_) as sty => writeMem(sty.addr,Y)

			| TAX => X = checkFlagNZ(A)
			| TXA => A = checkFlagNZ(X)
			| TAY => Y = checkFlagNZ(A)
			| TYA => A = checkFlagNZ(Y)
			| TSX => X = checkFlagNZ(S)
			| TXS => S = X

			| PHA => implPush(A)
			| PLA => A = checkFlagNZ(implPop())
			| PHP => implPush(P.GetValue())
			| PLP => P.SetValue(implPop())

			| NOP => ()
			| _ => throw NotImplementedException()

		}
		private implASL(m : byte) : byte {
			// {m[6:0], 0]} -> m
			// m[7] -> Carry
			def result : byte = m << 1;

			P.Carry = conv_b(m & 0x80);
			P.Zero = result == 0;
			P.Negative = conv_b(result & 0x80);

			result;
		}
		private implLSR(m : byte) : byte {
			// { 0, m[7:1]]} -> m
			// m[0] -> Carry
			def result : byte = (m >> 1) & 0x7f;

			P.Carry = conv_b(m & 0x1);
			P.Zero = result == 0;
			P.Negative = conv_b(result & 0x80);

			result;
		}
		private implROL(m : byte) : byte {
			// {m[6:0], Carry]} -> m
			// m[7] -> Carry
			def result = m << 1 | conv_i(P.Carry) :> byte;

			P.Carry = conv_b(m & 0x80);
			P.Zero = result == 0;
			P.Negative = conv_b(result & 0x80);

			result;
		}
		private implROR(m : byte) : byte {
			// { C, m[7:1]]} -> m
			// m[0] -> Carry
			def result = (m >> 1) | (conv_i(P.Carry) << 7) :> byte;

			P.Carry = conv_b(m & 0x1);
			P.Zero = result == 0;
			P.Negative = conv_b(result & 0x80);

			result;
		}
		private implBranch(status:bool) : void {
			| true => {
					def nextAddr = Mem[PC];
					PC += nextAddr + 1;
					//TODO:clocking
				}
			| false => PC++
		}
		private implPush(data:byte) : void {
			def pt = (0x0100 | SP) :> ushort;//上位ビットは$01固定
			Mem[pt] = data;
			SP--;
		}
		private implPop() : byte {
			SP++;
			def pt = (0x0100 | SP) :> ushort;//上位ビットは$01固定
			Mem[pt];
		}

		private implCMP(reg: byte, m : byte) : void {
			def result : int = reg - m;

			P.Negative = conv_b(result & 0x80);
			P.Carry = result >= 0x00 ;
			P.Zero = result == 0;
		}

		private implINC(reg:byte) : byte {
			def result = reg + 1;

			checkFlagNZ(result)
		}
		private implDEC(reg:byte) : byte {
			def result = reg - 1;

			checkFlagNZ(result)
		}

		private checkFlagNZ(data:byte) : byte {
			P.Negative = conv_b(data & 0x80);
			P.Zero = data == 0;
			data
		}
	}
}


