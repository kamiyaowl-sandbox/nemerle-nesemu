using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

using NESEmulatorMacro;

namespace NESEmulator{
	public class CPU {
		public A : byte {get; set;}
		public X : byte {get; set;}
		public Y : byte {get; set;}
		//stack ptr
		public S : byte {get; set;}
		//status register
		public P : byte {get; set;}
		//program counter
		public PC : byte {get; set;}

		public Mem : Memory {get; set;}

		public Initialize() : void {
			A = 0x0;
			X = 0x0;
			Y = 0x0;
			S = 0x0;
			P = 0x0;
			PC = 0x0;
		}

		public variant Address {
			| None
			| Accumelator
			| Relative
			| Data { addr : int}
		};
		public variant Addressing {
			| Accumulator//on Accumulator
			| Immediate//op1 is data
			| Absolute// op1, op2 => {op2, op1} : addr
			| ZeroPage//op1 => { $00, op1} : addr 
			| IndexedZeroPageX//op1 => {$00, op1 + (X | Y)} : addr
			| IndexedZeroPageY//op1 => {$00, op1 + (X | Y)} : addr
			| IndexedAbsoluteX//op1, op2 => { op2, op1 + (X | Y)} : addr
			| IndexedAbsoluteY//op1, op2 => { op2, op1 + (X | Y)} : addr
			| Implied //no address
			| Relative///op1 => {PC + op1} : addr
			| IndexedIndirectX//op1 => {op1 + X + 1, op1 + X} : addr
			| IndexedIndirectY//op1 => {op1 + 1, op1} + Y : addr
			| AbsoluteIndirect//op1, op2 => {{op2, op1} + 1, {op2, op1}} :addr
		};
		public variant OPCode {
			| ADC { addr:Addressing }
			| SBC { addr:Addressing }
			| AND { addr:Addressing }//a
			| ORA { addr:Addressing }//a
			| EOR { addr:Addressing }//a
			| ASL { addr:Addressing }//a <<
			| LSR { addr:Addressing }//a >>
			| ROL { addr:Addressing }// << rotate
			| ROR { addr:Addressing }// >> rotate

			| BCC { addr:Addressing }  //no carry jump
			| BCS { addr:Addressing }  //carry jump
			| BEQ { addr:Addressing } // == jump
			| BNE { addr:Addressing }  // != jump
			| BVC { addr:Addressing }  //no ovf jump
			| BVS { addr:Addressing }  //ovf jump
			| BPL { addr:Addressing } //jump if +
			| BMI { addr:Addressing }  //jump if -

			| BIT { addr:Addressing }//and a

			| JMP { addr:Addressing }

			| JSR //call subroutine
			| RTS //return subroutine
			| BRK //software interrupt
			| RTI //return interrupt

			| CMP { addr:Addressing }//a
			| CPX { addr:Addressing }
			| CPY { addr:Addressing }

			| INC { addr:Addressing }//a
			| DEC { addr:Addressing }//a

			| INX
			| DEX
			| INY
			| DEY

			| CLC // clear c
			| SEC // set c
			| CLI // clear i
			| SEI // set i
			| CLD // clear d
			| SED // set d
			| CLV // clear v

			| LDA { addr:Addressing }
			| LDX { addr:Addressing }
			| LDY { addr:Addressing }
			| STA { addr:Addressing }
			| STX { addr:Addressing }
			| STY { addr:Addressing }

			| TAX
			| TXA
			| TAY
			| TYA
			| TXS
			| TSX

			| PHA
			| PLA
			| PHP
			| PLP

			| NOP //none

		};
		public Convert(code : byte) : OPCode {
			| 0x69 => OPCode.ADC(Addressing.Immediate());
			| 0x65 => OPCode.ADC(Addressing.ZeroPage());
			| 0x75 => OPCode.ADC(Addressing.IndexedZeroPageX());
			| 0x6d => OPCode.ADC(Addressing.Absolute());
			| 0x7d => OPCode.ADC(Addressing.IndexedAbsoluteX());
			| 0x79 => OPCode.ADC(Addressing.IndexedAbsoluteY());
			| 0x61 => OPCode.ADC(Addressing.IndexedIndirectX());
			| 0x71 => OPCode.ADC(Addressing.IndexedIndirectY());

			| 0xe9 => OPCode.SBC(Addressing.Immediate());
			| 0xe5 => OPCode.SBC(Addressing.ZeroPage());
			| 0xf5 => OPCode.SBC(Addressing.IndexedZeroPageX());
			| 0xed => OPCode.SBC(Addressing.Absolute());
			| 0xfd => OPCode.SBC(Addressing.IndexedAbsoluteX());
			| 0xf9 => OPCode.SBC(Addressing.IndexedAbsoluteY());
			| 0xe1 => OPCode.SBC(Addressing.IndexedIndirectX());
			| 0xf1 => OPCode.SBC(Addressing.IndexedIndirectY());

			| 0x29 => OPCode.AND(Addressing.Immediate());
			| 0x25 => OPCode.AND(Addressing.ZeroPage());
			| 0x35 => OPCode.AND(Addressing.IndexedZeroPageX());
			| 0x2d => OPCode.AND(Addressing.Absolute());
			| 0x3d => OPCode.AND(Addressing.IndexedAbsoluteX());
			| 0x39 => OPCode.AND(Addressing.IndexedAbsoluteY());
			| 0x21 => OPCode.AND(Addressing.IndexedIndirectX());
			| 0x31 => OPCode.AND(Addressing.IndexedIndirectY());

			| 0x09 => OPCode.ORA(Addressing.Immediate());
			| 0x05 => OPCode.ORA(Addressing.ZeroPage());
			| 0x15 => OPCode.ORA(Addressing.IndexedZeroPageX());
			| 0x0d => OPCode.ORA(Addressing.Absolute());
			| 0x1d => OPCode.ORA(Addressing.IndexedAbsoluteX());
			| 0x19 => OPCode.ORA(Addressing.IndexedAbsoluteY());
			| 0x01 => OPCode.ORA(Addressing.IndexedIndirectX());
			| 0x11 => OPCode.ORA(Addressing.IndexedIndirectY());

			| 0x49 => OPCode.EOR(Addressing.Immediate());
			| 0x55 => OPCode.EOR(Addressing.ZeroPage());
			| 0x55 => OPCode.EOR(Addressing.IndexedZeroPageX());
			| 0x4d => OPCode.EOR(Addressing.Absolute());
			| 0x5d => OPCode.EOR(Addressing.IndexedAbsoluteX());
			| 0x59 => OPCode.EOR(Addressing.IndexedAbsoluteY());
			| 0x41 => OPCode.EOR(Addressing.IndexedIndirectX());
			| 0x51 => OPCode.EOR(Addressing.IndexedIndirectY());

			| 0x0a => OPCode.ASL(Addressing.Accumulator());
			| 0x06 => OPCode.ASL(Addressing.ZeroPage());
			| 0x16 => OPCode.ASL(Addressing.IndexedZeroPageX());
			| 0x0e => OPCode.ASL(Addressing.Absolute());
			| 0x1e => OPCode.ASL(Addressing.IndexedAbsoluteX());

			| 0x4a => OPCode.LSR(Addressing.Accumulator());
			| 0x46 => OPCode.LSR(Addressing.ZeroPage());
			| 0x56 => OPCode.LSR(Addressing.IndexedZeroPageX());
			| 0x4e => OPCode.LSR(Addressing.Absolute());
			| 0x5e => OPCode.LSR(Addressing.IndexedAbsoluteX());

			| 0x2a => OPCode.ROL(Addressing.Accumulator());
			| 0x26 => OPCode.ROL(Addressing.ZeroPage());
			| 0x36 => OPCode.ROL(Addressing.IndexedZeroPageX());
			| 0x2e => OPCode.ROL(Addressing.Absolute());
			| 0x3e => OPCode.ROL(Addressing.IndexedAbsoluteX());

			| 0x6a => OPCode.ROR(Addressing.Accumulator());
			| 0x66 => OPCode.ROR(Addressing.ZeroPage());
			| 0x76 => OPCode.ROR(Addressing.IndexedZeroPageX());
			| 0x6e => OPCode.ROR(Addressing.Absolute());
			| 0x7e => OPCode.ROR(Addressing.IndexedAbsoluteX());

			| 0x90 => OPCode.BCC(Addressing.Relative());
			| 0xb0 => OPCode.BCS(Addressing.Relative());
			| 0xf0 => OPCode.BEQ(Addressing.Relative());
			| 0xd0 => OPCode.BNE(Addressing.Relative());
			| 0x50 => OPCode.BVC(Addressing.Relative());
			| 0x70 => OPCode.BVS(Addressing.Relative());
			| 0x10 => OPCode.BPL(Addressing.Relative());
			| 0x30 => OPCode.BMI(Addressing.Relative());

			| 0x24 => OPCode.BIT(Addressing.ZeroPage());
			| 0x2c => OPCode.BIT(Addressing.Absolute());

			| 0x4c => OPCode.JMP(Addressing.Absolute());
			| 0x6c => OPCode.JMP(Addressing.IndexedIndirectX());//TODO?

			| 0x20 => OPCode.JSR();
			| 0x60 => OPCode.RTS();
			| 0x00 => OPCode.BRK();
			| 0x40 => OPCode.RTI();

			| 0xc9 => OPCode.CMP(Addressing.Immediate());
			| 0xc5 => OPCode.CMP(Addressing.ZeroPage());
			| 0xd5 => OPCode.CMP(Addressing.IndexedZeroPageX());
			| 0xcd => OPCode.CMP(Addressing.Absolute());
			| 0xdd => OPCode.CMP(Addressing.IndexedAbsoluteX());
			| 0xd9 => OPCode.CMP(Addressing.IndexedAbsoluteY());
			| 0xc1 => OPCode.CMP(Addressing.IndexedIndirectX());
			| 0xd1 => OPCode.CMP(Addressing.IndexedIndirectY());

			| 0xe0 => OPCode.CPX(Addressing.Immediate());
			| 0xe4 => OPCode.CPX(Addressing.ZeroPage());
			| 0xec => OPCode.CPX(Addressing.Absolute());

			| 0x00 => OPCode.CPY(Addressing.Immediate());
			| 0xc4 => OPCode.CPY(Addressing.ZeroPage());
			| 0xcc => OPCode.CPY(Addressing.Absolute());

			| 0xe6 => OPCode.INC(Addressing.ZeroPage());
			| 0xf6 => OPCode.INC(Addressing.IndexedZeroPageX());
			| 0xee => OPCode.INC(Addressing.Absolute());
			| 0xfe => OPCode.INC(Addressing.IndexedAbsoluteX());

			| 0xc6 => OPCode.DEC(Addressing.ZeroPage());
			| 0xd6 => OPCode.DEC(Addressing.IndexedZeroPageX());
			| 0xce => OPCode.DEC(Addressing.Absolute());
			| 0xde => OPCode.DEC(Addressing.IndexedAbsoluteX());

			| 0xe8 => OPCode.INX();
			| 0xca => OPCode.DEX();
			| 0xc8 => OPCode.INY();
			| 0x88 => OPCode.DEY();

			| 0x18 => OPCode.CLC();
			| 0x38 => OPCode.SEC();
			| 0x58 => OPCode.CLI();
			| 0x78 => OPCode.SEI();
			| 0xd8 => OPCode.CLD();
			| 0xf8 => OPCode.SED();
			| 0xb8 => OPCode.CLV();

			| 0xa9 => OPCode.LDA(Addressing.Immediate());
			| 0xa5 => OPCode.LDA(Addressing.ZeroPage());
			| 0xb5 => OPCode.LDA(Addressing.IndexedZeroPageX());
			| 0xad => OPCode.LDA(Addressing.Absolute());
			| 0xbd => OPCode.LDA(Addressing.IndexedAbsoluteX());
			| 0xb9 => OPCode.LDA(Addressing.IndexedAbsoluteY());
			| 0xa1 => OPCode.LDA(Addressing.IndexedIndirectX());
			| 0xb1 => OPCode.LDA(Addressing.IndexedIndirectY());

			| 0xa9 => OPCode.LDX(Addressing.Immediate());
			| 0xa5 => OPCode.LDX(Addressing.ZeroPage());
			| 0xa5 => OPCode.LDX(Addressing.IndexedZeroPageY());
			| 0xad => OPCode.LDX(Addressing.Absolute());
			| 0xb9 => OPCode.LDX(Addressing.IndexedAbsoluteY());

			| 0xa0 => OPCode.LDY(Addressing.Immediate());
			| 0xa4 => OPCode.LDY(Addressing.ZeroPage());
			| 0xb4 => OPCode.LDY(Addressing.IndexedZeroPageX());
			| 0xac => OPCode.LDY(Addressing.Absolute());
			| 0xbc => OPCode.LDY(Addressing.IndexedAbsoluteX());

			| 0x85 => OPCode.STA(Addressing.ZeroPage());
			| 0x95 => OPCode.STA(Addressing.IndexedZeroPageX());
			| 0x8d => OPCode.STA(Addressing.Absolute());
			| 0x9d => OPCode.STA(Addressing.IndexedAbsoluteX());
			| 0x99 => OPCode.STA(Addressing.IndexedAbsoluteY());
			| 0x81 => OPCode.STA(Addressing.IndexedIndirectX());
			| 0x91 => OPCode.STA(Addressing.IndexedIndirectY());

			| 0x86 => OPCode.STX(Addressing.ZeroPage());
			| 0x96 => OPCode.STX(Addressing.IndexedZeroPageY());
			| 0x8e => OPCode.STX(Addressing.Absolute());

			| 0x84 => OPCode.STY(Addressing.ZeroPage());
			| 0x94 => OPCode.STY(Addressing.IndexedZeroPageX());
			| 0x8c => OPCode.STY(Addressing.Absolute());

			| 0xaa => OPCode.TAX();
			| 0x8a => OPCode.TXA();
			| 0xa8 => OPCode.TAY();
			| 0x98 => OPCode.TYA();
			| 0x9a => OPCode.TXS();
			| 0xba => OPCode.TSX();

			| 0x48 => OPCode.PHA();
			| 0x68 => OPCode.PLA();
			| 0x08 => OPCode.PHP();
			| 0x28 => OPCode.PLP();

			| 0xea => OPCode.NOP();

		}
		public ReadAddr(addr:Addressing) : Address {
				//Aレジスタの値をそのまま参照してね
			| Addressing.Accumulator => Address.Accumelator();
				//PCの即値を適用(PCを進めとく)
			| Addressing.Immediate => { def x = PC ; PC++ ; Address.Data(x)}
				//下位アドレス
			| Addressing.ZeroPage => { def x = Mem.Read(PC) ; PC++ ; Address.Data(x) }
			| Addressing.IndexedZeroPageX => { def x = Mem.Read(PC) + X ; PC++ ; Address.Data(x) }
			| Addressing.IndexedZeroPageY => { def x = Mem.Read(PC) + Y ; PC++ ; Address.Data(x) }
				//下位アドレス, 上位アドレス
			| Addressing.Absolute => { def x = Mem.Read(PC) | (Mem.Read(PC + 1) << 8); PC += 2; Address.Data(x) }
			| Addressing.IndexedAbsoluteX => { def x = Mem.Read(PC) | (Mem.Read(PC + 1) << 8) + X; PC += 2; Address.Data(x) }
			| Addressing.IndexedAbsoluteY => { def x = Mem.Read(PC) | (Mem.Read(PC + 1) << 8) + Y; PC += 2; Address.Data(x) }
				//使わない
			| Addressing.Implied => Address.None();
			| Addressing.Relative => Address.Relative();
				//(下位アドレス先 + X)のアドレス先(下位ビット) とその先1byte(上位ビット)
			| Addressing.IndexedIndirectX => { def pt = Mem.Read(PC) + X; def x = Mem.Read(pt) | (Mem.Read(pt + 1) << 8) ; PC++ ;  Address.Data(x) }
				//下位アドレス先のアドレス先(下位ビット) とその先1byte(上位ビット) にYを加算
			| Addressing.IndexedIndirectY => { def pt = Mem.Read(PC); def x = (Mem.Read(pt) | (Mem.Read(pt + 1) << 8)) + Y ; PC++ ;  Address.Data(x) }
				//TODO:Absoluteとどう違うかわからん
			| Addressing.Absolute => { def x = Mem.Read(PC) | (Mem.Read(PC + 1) << 8); PC += 2; Address.Data(x) }

			| _ => throw Exception();

		}
		public Execute(opcode : OPCode) : void {
		}

	}

}
